# -*- coding: utf-8 -*-
"""AER8503.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19bulXiQh0h--vgKKyHs53sM9mjiN0ZsT
"""

# Step 1 Object Masking

#  Install necessary libraries


import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the motherboard image (replace 'motherboard_image.JPEG' with your actual file path)
image = cv2.imread('/content/drive/MyDrive/Colab Notebooks/motherboard_image.JPEG')

# Convert image to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Thresholding
_, thresholded = cv2.threshold(gray, 120, 255, cv2.THRESH_BINARY)

# Edge detection using Canny
edges = cv2.Canny(thresholded, 50, 300)

# Contour detection
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Create a mask
mask = np.zeros_like(gray)

# Draw contours
cv2.drawContours(mask, contours, -1, 255, thickness=cv2.FILLED)

# Apply mask to the original image
edges_rgb = cv2.cvtColor(edges, cv2.COLOR_GRAY2RGB)
masked_image = cv2.bitwise_and(image, image, mask=mask)
masked_image_rgb = cv2.cvtColor(masked_image, cv2.COLOR_BGR2RGB)

# Display original and processed images
plt.figure(figsize=(15, 5))

plt.subplot(131)
plt.title("Edge Detection")
plt.imshow(cv2.cvtColor(edges_rgb, cv2.COLOR_BGR2RGB))

plt.subplot(132)
plt.title("Masked Image")
plt.imshow(cv2.cvtColor(masked_image, cv2.COLOR_BGR2RGB))

plt.subplot(133)
plt.title('Final Extracted PCB')
plt.imshow(masked_image_rgb)

plt.tight_layout()
plt.show()

#Step 2 Model Training

!pip install ultralytics opencv-python-headless matplotlib

# Import libraries
from ultralytics import YOLO
import os
import yaml

model = YOLO('yolov8n.pt')

# Start training on your custom dataset
model.train(data="/content/drive/MyDrive/Colab Notebooks/data_set/data.yaml",
    epochs=50,  # Set as needed (<=200)
    batch=5,
    imgsz=928,  # Image size
    name='pcb_model2'
)

# Step 2.5 Matrices and Graph Curves
import matplotlib.image as mpimg

# Normalized confusion matrix
conf_matrix = mpimg.imread('/content/runs/detect/pcb_model2/confusion_matrix_normalized.png')
plt.figure(figsize=(12, 8))
plt.imshow(conf_matrix)
plt.axis('off')
plt.show()

# Precision-Confidence curve
pc_curve = mpimg.imread('/content/runs/detect/pcb_model2/P_curve.png')
plt.figure(figsize=(12, 8))
plt.imshow(pc_curve)
plt.axis('off')
plt.show()

# Precision-Recall curve
pr_curve = mpimg.imread('/content/runs/detect/pcb_model2/PR_curve.png')
plt.figure(figsize=(12, 8))
plt.imshow(pr_curve)
plt.axis('off')
plt.show()

# Step 3 Evaluation

from google.colab.patches import cv2_imshow

model = YOLO('/content/runs/detect/pcb_model2/weights/last.pt')

images = [
    '/content/drive/MyDrive/Colab Notebooks/data_set/evaluation/ardmega.jpg',
    '/content/drive/MyDrive/Colab Notebooks/data_set/evaluation/arduno.jpg',
    '/content/drive/MyDrive/Colab Notebooks/data_set/evaluation/rasppi.jpg'
]

for img in images:
    print(f"\nResults for: {img.split('/')[-1]}")
    results = model.predict(img, imgsz=1024, conf=0.25)
    cv2_imshow(results[0].plot())

